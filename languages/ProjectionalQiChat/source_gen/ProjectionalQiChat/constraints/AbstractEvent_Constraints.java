package ProjectionalQiChat.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.base.BaseConstraintsDescriptor;
import jetbrains.mps.smodel.runtime.ConstraintFunction;
import jetbrains.mps.smodel.runtime.ConstraintContext_CanBeChild;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.runtime.CheckingNodeContext;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class AbstractEvent_Constraints extends BaseConstraintsDescriptor {
  public AbstractEvent_Constraints() {
    super(CONCEPTS.AbstractEvent$sH);
  }

  @Override
  protected ConstraintFunction<ConstraintContext_CanBeChild, Boolean> calculateCanBeChildConstraint() {
    return new ConstraintFunction<ConstraintContext_CanBeChild, Boolean>() {
      @NotNull
      public Boolean invoke(@NotNull ConstraintContext_CanBeChild context, @Nullable CheckingNodeContext checkingNodeContext) {
        boolean result = staticCanBeAChild(context.getNode(), context.getParentNode(), context.getConcept(), context.getLink());

        if (!(result) && checkingNodeContext != null) {
          checkingNodeContext.setBreakingNode(canBeChildBreakingPoint);
        }

        return result;
      }
    };
  }
  private static boolean staticCanBeAChild(SNode node, SNode parentNode, SAbstractConcept childConcept, SContainmentLink link) {

    boolean parentIsHumanInput = SNodeOperations.isInstanceOf(parentNode, CONCEPTS.HumanInput$T5);
    boolean nodeIsInHumanInput = (SNodeOperations.getNodeAncestor(parentNode, CONCEPTS.HumanInput$T5, false, false) != null) || parentIsHumanInput;
    boolean parentIsInputChoice = SNodeOperations.isInstanceOf(parentNode, CONCEPTS.InputChoice$KG);
    boolean parentIsPhrase = SNodeOperations.isInstanceOf(parentNode, CONCEPTS.Phrase$1a);
    SNode ancestorHumanInput = null;
    if (parentIsHumanInput) {
      ancestorHumanInput = SNodeOperations.as(parentNode, CONCEPTS.HumanInput$T5);
    } else {
      ancestorHumanInput = SNodeOperations.getNodeAncestor(parentNode, CONCEPTS.HumanInput$T5, false, false);
    }
    boolean parentHumanInputHasMaxOneEvent = ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.AbstractEvent$sH, false, new SAbstractConcept[]{})).count() == 0 || (ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.AbstractEvent$sH, false, new SAbstractConcept[]{})).contains(node) && ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.AbstractEvent$sH, false, new SAbstractConcept[]{})).count() == 1);
    boolean onlyOneChoiceHaveEvents = ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.InputChoice$KG, false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ListSequence.fromList(SLinkOperations.getChildren(it, LINKS.choices$YXnx)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(it, CONCEPTS.AbstractEvent$sH);
          }
        }).count() > 0;
      }
    }).count() <= 1;
    boolean allEventsAreInOneChoice = ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.AbstractEvent$sH, false, new SAbstractConcept[]{})).all(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (SNodeOperations.getNodeAncestor(it, CONCEPTS.InputChoice$KG, false, false) != null);
      }
    }) && onlyOneChoiceHaveEvents;

    // Rules for beeing child
    if (parentIsHumanInput) {
      return parentHumanInputHasMaxOneEvent;
    }
    if (nodeIsInHumanInput) {
      if (parentHumanInputHasMaxOneEvent) {
        return parentIsInputChoice || parentIsPhrase;
      }
      if (allEventsAreInOneChoice) {
        boolean allChoicesDontHaveEvents = ListSequence.fromList(SNodeOperations.getNodeDescendants(ancestorHumanInput, CONCEPTS.InputChoice$KG, false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return ListSequence.fromList(SLinkOperations.getChildren(it, LINKS.choices$YXnx)).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return SNodeOperations.isInstanceOf(it, CONCEPTS.AbstractEvent$sH);
              }
            }).count() > 0;
          }
        }).count() == 0;
        SNode parent = null;
        if (parentIsInputChoice) {
          parent = SNodeOperations.as(parentNode, CONCEPTS.InputChoice$KG);
        } else {
          parent = SNodeOperations.getNodeAncestor(parentNode, CONCEPTS.InputChoice$KG, false, false);
        }
        if ((parent != null)) {
          boolean ancestorIsInputChoiceWithEvents = ListSequence.fromList(SNodeOperations.getNodeDescendants(parent, CONCEPTS.AbstractEvent$sH, false, new SAbstractConcept[]{})).count() > 0;
          if (parentIsInputChoice || parentIsPhrase) {
            return allChoicesDontHaveEvents || ancestorIsInputChoiceWithEvents;
          }
        }
      }
    }
    return false;
  }
  private static final SNodePointer canBeChildBreakingPoint = new SNodePointer("r:0732640b-7693-4dcb-8a72-67b764f4b543(ProjectionalQiChat.constraints)", "6218627430235616570");

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractEvent$sH = MetaAdapterFactory.getConcept(0x9f283760f9ca4f5bL, 0x8990d42851344ce7L, 0x6fd223061c49b160L, "ProjectionalQiChat.structure.AbstractEvent");
    /*package*/ static final SConcept HumanInput$T5 = MetaAdapterFactory.getConcept(0x9f283760f9ca4f5bL, 0x8990d42851344ce7L, 0x6fd223061c49b034L, "ProjectionalQiChat.structure.HumanInput");
    /*package*/ static final SConcept InputChoice$KG = MetaAdapterFactory.getConcept(0x9f283760f9ca4f5bL, 0x8990d42851344ce7L, 0x6fd223061c49b114L, "ProjectionalQiChat.structure.InputChoice");
    /*package*/ static final SConcept Phrase$1a = MetaAdapterFactory.getConcept(0x9f283760f9ca4f5bL, 0x8990d42851344ce7L, 0x6fd223061c49b121L, "ProjectionalQiChat.structure.Phrase");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink choices$YXnx = MetaAdapterFactory.getContainmentLink(0x9f283760f9ca4f5bL, 0x8990d42851344ce7L, 0x6fd223061c49b114L, 0xf8c3893a78b2520L, "choices");
  }
}
